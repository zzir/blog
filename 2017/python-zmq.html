<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="zzir">
    <meta name="description" content="">
    <meta name="keywords" content="">
    
    <link rel="stylesheet" href="../css/style.css">
    
    <link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Caveat&display=swap" rel="stylesheet" type="text/css">
    
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"></script>
    
    <link rel="stylesheet" href="../css/github.css">
    <script src="../js/highlight.pack.js"></script>
    <title>Python ZMQ - zzir</title>

    <script>
        hljs.initHighlightingOnLoad();
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
</head>
<body>

    <main>
        <article>
            <h1 class="post-title">Python ZMQ</h1>
            <div class="post-info">
                <p class="post-date">Aug 31, 2017</p>
            </div>
            <div class="post-content">
                


  
  
  



<h2 id="zmq-allowed-patterns">ZMQ Allowed Patterns</h2>

<ul>
<li>PUB and SUB</li>
<li>REQ and REP</li>
<li>REQ and ROUTER</li>
<li>DEALER and REP</li>
<li>DEALER and ROUTER</li>
<li>DEALER and DEALER</li>
<li>ROUTER and ROUTER</li>
<li>PUSH and PULL</li>
<li>PAIR and PAIR</li>
</ul>

<h2 id="zmq模式">ZMQ模式</h2>

<h3 id="req-rep">REQ-REP</h3>

<p><img src="/imgs/201708-fig2.png" alt=""/></p>

<p>请求-应答：由请求端发起请求，并等待回应端回应请求。从请求端来看，一定是一对对收发配对的；反之，在回应端一定是发收对。请求端和回应端都可以是1：N的模型。通常把1认为是server，N认为是Client。</p>

<p>注意：</p>

<ol>
<li>必须先提问，后回答</li>
<li>对于一个提问，只能回答一次</li>
<li>在没有收到回答前不能再次提问</li>
</ol>

<p><strong>举个栗子</strong></p>

<p>Request:</p>

<pre><code class="language-python">import zmq

context = zmq.Context()
socket = content.socket(zmq.REQ)
socket.connect(&#39;tcp://127.0.0.1:10000&#39;)

for _ in range(1, 11):
    socket.send(b&#39;hello, i am msg-%s&#39; % _)
    message = socket.recv()
    print(&#34;Received reply %d [%s]&#34; % (_, message))

</code></pre>

<p>Reply:</p>

<pre><code>import zmq
import time

context = zmq.Context()
socket = content.socket(zmq.REP)
socket.bind(&#39;tcp://127.0.0.1:10000&#39;)

while True:
    message = socket.recv()
    print(&#34;Received request: %s &#34; % message)
    time.sleep(1)
    socket.send(&#34;yay, it&#39;s ok.&#34;)
</code></pre>

<h4 id="extended-request-reply">Extended Request-Reply</h4>

<p>关于 DEALER 和 ROUTE：</p>

<p><img src="/imgs/201708-fig27.png" alt=""/></p>

<p>DEALER 类似一个异步的 REQ Socket。</p>

<p>ROUTE 类似一个一部的 REP Socket。</p>

<p>你依然可以使用REQ，也可以使用DEALER，它们有两个不同：</p>

<ul>
<li>The REQ socket always sends an empty delimiter frame before any data frames; the DEALER does not.</li>
<li>The REQ socket will send only one message before it receives a reply; the DEALER is fully asynchronous.</li>
</ul>

<p>看一个具体的例子：</p>

<p><img src="/imgs/201708-fig16.png" alt=""/></p>

<p>Broker:</p>

<pre><code class="language-python">import zmq

context = zmq.Context()

frontend = context.socket(zmq.ROUTER)
frontend.bind(&#39;tcp://127.0.0.1:5559&#39;)

backend = context.socket(zmq.DEALER)
backend.bind(&#39;tcp://127.0.0.1:5560&#39;)

# init poll set
poller = zmq.Poller()
poller.register(frontend, zmq.POLLIN)
poller.register(backend, zmq.POLLIN)

while True:
    socks = dict(poller.poll())

    if socks.get(frontend) == zmq.POLLIN:
        message = frontend.recv_multipart()
        backend.send_multipart(message)

    if socks.get(backend) == zmq.POLLIN:
        message = backend.recv_multipart()
        frontend.send_multipart(message)
</code></pre>

<p>Client:</p>

<pre><code class="language-python">import zmq

#  Prepare our context and sockets
context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect(&#34;tcp://127.0.0.1:5559&#34;)

#  Do 10 requests, waiting each time for a response
for request in range(1,11):
    socket.send(b&#34;Hello&#34;)
    message = socket.recv()
    print(&#34;Received reply %s [%s]&#34; % (request, message))

</code></pre>

<p>Server:</p>

<pre><code class="language-python">import zmq

context = zmq.Context()
socket = context.socket(zmq.REP)
socket.connect(&#34;tcp://127.0.0.1:5560&#34;)

while True:
    message = socket.recv()
    print(&#34;Received request: %s&#34; % message)
    socket.send(b&#34;World&#34;)

</code></pre>

<p>客户端和服务端相对透明，唯一的静态节点代理在中间。</p>

<h3 id="pub-sub">PUB-SUB</h3>

<p><img src="/imgs/201708-fig4.png" alt=""/></p>

<p>发布-订阅：类似广播。这个模型里，发布端是单向只发送数据的，且不关心是否把全部的信息都发送给订阅者。如果发布端开始发布信息的时候，订阅端尚未连接上，这些信息直接丢弃。不过一旦订阅连接上来，中间会保证没有信息丢失。同样，订阅端则只负责接收，而不能反馈。如果发布端和订阅端需要交互（比如要确认订阅者是否已经连接上），则使用额外的socket采用请求回应模型满足这个需求。</p>

<p>举个栗子：</p>

<p>Publisher</p>

<pre><code class="language-python">import zmq
import random
import time

port = &#34;10001&#34;

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.bind(&#34;tcp://127.0.0.1:%s&#34; % port)

while True:
    topic = random.randrange(9999, 10005)
    messagedata = random.randrange(1, 215) - 80
    print(&#34;%d %d&#34; % (topic, messagedata))
    socket.send(&#34;%d %d&#34; % (topic, messagedata))
    time.sleep(1)
</code></pre>

<p>Subscriber:</p>

<p>Publisher像广播一样一直在发送，不管Subscriber是否接收得到，当Subscriber连接上Publisher之后，从连上那一刻开始接收KEY为10001的内容，满5次自动断开。Publisher依然会向端口广播消息，不论Subscriber是否连接。</p>

<pre><code class="language-python">import zmq

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print(&#34;Collecting updates from weather server...&#34;)
socket.connect(&#34;tcp://127.0.0.1:10001&#34;)

# Subscribe to zipcode, default is NYC, 10001, not port
topicfilter = &#34;10001&#34;
socket.setsockopt(zmq.SUBSCRIBE, topicfilter)

# Process 5 updates
total_value = 0
for update_nbr in range(5):
    string = socket.recv()
    topic, messagedata = string.split()
    total_value += int(messagedata)
    print(&#39;topic: %s  messagedata: %s&#39; %(topic, messagedata))

print(
    &#34;Average value: topic &#39;%s&#39; messagedata %dF&#34; %
    (topicfilter, total_value / update_nbr)
)
</code></pre>

<h3 id="push-pull">PUSH-PULL</h3>

<p><img src="/imgs/201708-fig5.png" alt=""/></p>

<p>管道模式。这个模型里，管道是单向的，从PUSH端单向的向PULL端单向的推送数据流。</p>

<p>举个栗子：</p>

<p>Ventilator:</p>

<pre><code class="language-python">import zmq
import random

context = zmq.Context()

ventilator = context.socket(zmq.PUSH)
ventilator.bind(&#34;tcp://127.0.0.1:5557&#34;)

# random.seed()

while True:
    workload = random.randint(1, 100)
    ventilator.send(str(workload))
</code></pre>

<p>Worker:</p>

<pre><code class="language-python">import zmq

context = zmq.Context()

ventilator = content.socket(zmq.PULL)
ventilator.connect(&#39;tcp://127.0.0.1:5557&#39;)

sink = content.socket(zmq.PUSH)
sink.connect(&#39;tcp://127.0.0.1:5558&#39;)

while True:
    # do something
    recv = ventilator.recv()
    sink.send(recv)
</code></pre>

<p>Sink:</p>

<pre><code class="language-python">import zmq

context = zmq.Context()

sink = context.socket(zmq.PULL)
sink.bind(&#34;tcp://127.0.0.1:5558&#34;)

while True:
    print sink.recv()
</code></pre>

<h3 id="pair">PAIR</h3>

<p><img src="/imgs/201708-pair.png" alt=""/></p>

<p>在一个进程中，用于两个线程间的通信。</p>

<p>Conventional sockets allow:</p>

<ul>
<li>only strict one-to-one (two peers)</li>
<li>many-to-one (many clients, one server)</li>
<li>one-to-many (multicast) relationships</li>
</ul>

<p><strong>Exclusive pair pattern</strong></p>

<p>Paired sockets are very similar to regular sockets.</p>

<ul>
<li>The communication is bidirectional.</li>
<li>There is no specific state stored within the socket</li>
<li>There can only be one connected peer.</li>
<li>The server listens on a certain port and a client connects to it.</li>
</ul>

<p>举个栗子：</p>

<p>服务端和客户端可以发送任意的消息数量。</p>

<p>Server:</p>

<pre><code class="language-python">import zmq
import random
import time

port = &#34;5556&#34;
context = zmq.Context()
socket = context.socket(zmq.PAIR)
socket.bind(&#34;tcp://*:%s&#34; % port)

while True:
    socket.send(&#34;Server message to client3&#34;)
    msg = socket.recv()
    print msg
    time.sleep(1)
</code></pre>

<p>Client:</p>

<pre><code class="language-python">import zmq
import random
import time

port = &#34;5556&#34;
context = zmq.Context()
socket = context.socket(zmq.PAIR)
socket.connect(&#34;tcp://localhost:%s&#34; % port)

while True:
    msg = socket.recv()
    print msg
    socket.send(&#34;client message to server1&#34;)
    socket.send(&#34;client message to server2&#34;)
    time.sleep(1)
</code></pre>

<h2>路由</h2>

<p>更复杂的网络模型。ZMQ可以很好的支持路由功能（实现路由功能的组件叫做Device），把1：N扩展为N：M（只需要加入若干路由节点）。从这个模型看，更底层的端点地址是对上层隐藏的。每个请求都隐含回应地址，而应用则不关心它。</p>

<p>Device 组件有 3 个基本模式：</p>

<ul>
<li>Queue</li>
<li>Forwarder</li>
<li>Streamer</li>
</ul>

<p>还有新的Proxy()。</p>

<h3 id="queue-device">Queue Device</h3>

<p><img src="/imgs/201708-Queue.png" alt=""/></p>

<p>Queue 是位于客户端和服务器之间的中介，将客户端的请求转发给服务端，再将收到的服务端的回应转发给客户端。</p>

<p>Queue:</p>

<pre><code class="language-python">import zmq

def main():
    try:
        context = zmq.Context(1)
        frontend = content.socket(zmq.XREP)
        frontend.bind(&#39;tcp://*:5559&#39;)

        backend = content.socket(zmq.XREQ)
        backend.bind(&#39;tcp://*:5560&#39;)

        zmq.device(zmq.QUEUE, frontend, backend)
    except Exception, e:
        print e
        print &#34;bringing down zmq device&#34;
    finally:
        pass
        frontend.close()
        backend.close()
        content.term()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>Client:</p>

<pre><code class="language-python">import zmq
import random

port = &#39;5559&#39;
context = zmq.Context()

print &#39;Connecting to server...&#39;
socket = content.socket(zmq.REQ)
socket.connect(&#39;tcp://localhost:%s&#39; % port)

client_id = random.randrange(1, 10005)

for request in range(1, 11):
    print &#39;Sending request &#39;, request
    socket.send(&#39;Hello from %s &#39; % client_id)

    message = socket.recv()
    print &#39;Received reply %d [%s]&#39; % (request, message)
</code></pre>

<p>Server:</p>

<pre><code class="language-python">import zmq
import time
import random

port = &#39;5560&#39;

context = zmq.Context()
socket = content.socket(zmq.REP)
socket.connect(&#39;tcp://localhost:%s&#39; % port)

server_id = random.randrange(1, 10005)

while True:
    message = socket.recv()
    print &#39;Received request: &#39;, message
    time.sleep(1)
    socket.send(&#39;World from server %s&#39; % server_id)
</code></pre>

<p>如果想查看负载均衡效果，可以运行多个客户端和服务端。客户端的请求会经由中介分配到不同的服务器。</p>

<h3 id="forwarder">Forwarder</h3>

<p><img src="/imgs/201708-forwarder.png" alt=""/></p>

<p>如同 QUEUE 的 request-reply 模式。FORWARDER 像 pub-sub 的代理服务器。它允许 publishers 和 subscribers 移动部件，FORWARDER 是中心部件负责连接所有的publishers和subscribers。</p>

<p>Forwarder:</p>

<pre><code class="language-python">import zmq

def main():
    try:
        context = zmq.Context(1)

        # sub
        frontend = context.socket(zmq.SUB)
        frontend.bind(&#34;tcp://127.0.0.1:5559&#34;)

        frontend.setsockopt(zmq.SUBSCRIBE, &#34;&#34;)

        # pub
        backend = context.socket(zmq.PUB)
        backend.bind(&#34;tcp://127.0.0.1:5560&#34;)

        # forwarder
        zmq.device(zmq.FORWARDER, frontend, backend)
    except Exception, e:
        print e
        print &#34;bringing down zmq device&#34;
    finally:
        pass
        frontend.close()
        backend.close()
        context.term()

if __name__ == &#34;__main__&#34;:
    main()
</code></pre>

<p>Client:</p>

<pre><code class="language-python">import zmq

port = &#34;5560&#34;

context = zmq.Context()
socket = context.socket(zmq.SUB)

print &#34;Collecting updates from server...&#34;
socket.connect(&#34;tcp://localhost:%s&#34; % port)

topicfilter = &#34;9&#34;
socket.setsockopt(zmq.SUBSCRIBE, topicfilter)

for update_nbr in range(10):
    string = socket.recv()
    topic, messagedata = string.split()
    print topic, messagedata
</code></pre>

<p>Server:</p>

<pre><code class="language-python">import zmq
import random
import time

port = &#34;5559&#34;

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.connect(&#34;tcp://localhost:%s&#34; % port)

publisher_id = random.randrange(0, 9999)

while True:
    topic = random.randrange(1,10)
    messagedata = &#34;server#%s&#34; % publisher_id
    print &#34;%s %s&#34; % (topic, messagedata)
    socket.send(&#34;%d %s&#34; % (topic, messagedata))
    time.sleep(1)
</code></pre>

<h3 id="streamer">Streamer</h3>

<p><img src="/imgs/201708-streamer.png" alt=""/></p>

<p>Streamer 用于并行管道消息通信。作为一个代理，从PUSH端收集任务并发放给PULL端。</p>

<p>Streamer:</p>

<pre><code class="language-python">import zmq

def main():
    try:
        context = zmq.Context()

        # pull
        frontend = context.socket(zmq.PULL)
        frontend.bind(&#39;tcp://127.0.0.1:5559&#39;)

        # push
        backend = context.socket(zmq.PUSH)
        backend.bind(&#39;tcp://127.0.0.1:5560&#39;)

        # streamer
        zmq.device(zmq.STREAMER, frontend, backend)
    except Exception, e:
        print e
        print &#39;streamer_device&#39;
    finally:
        pass
        frontend.close()
        backend.close()
        context.term()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>PUSH:</p>

<pre><code class="language-python">import time
import zmq

def producer():
    context = zmq.Context()
    zmq_socket = context.socket(zmq.PUSH)
    zmq_socket.connect(&#34;tcp://127.0.0.1:5559&#34;)
    # push
    for num in xrange(20000):
        work_message = {&#39;num&#39;: num}
        zmq_socket.send_json(work_message)
        time.sleep(1)

producer()
</code></pre>

<p>PULL:</p>

<pre><code class="language-python">import zmq
import random

def consumer():
    context = zmq.Context()
    # pull
    consumer_receiver = context.socket(zmq.PULL)
    consumer_receiver.connect(&#34;tcp://127.0.0.1:5560&#34;)

    consumer_id = random.randrange(1, 10005)
    print &#34;I am consumer #%s&#34; % (consumer_id)

    while True:
        work = consumer_receiver.recv_json()
        data = work[&#39;num&#39;]
        result = {&#39;consumer&#39;: consumer_id, &#39;num&#39;: data}
        print result

consumer()
</code></pre>

<h3 id="proxy">Proxy()</h3>

<p>用于替代Device。</p>

<p>Show me The Code:</p>

<pre><code class="language-python">import zmq

def main():
    context = zmq.Context()

    # Socket facing clients
    frontend = context.socket(zmq.ROUTER)
    frontend.bind(&#34;tcp://127.0.0.1:5559&#34;)

    # Socket facing services
    backend = context.socket(zmq.DEALER)
    backend.bind(&#34;tcp://127.0.0.1:5560&#34;)

    zmq.proxy(frontend, backend)

    # We never get here
    frontend.close()
    backend.close()
    context.term()

if __name__ == &#34;__main__&#34;:
    main()
</code></pre>

<hr/>

<p>参考链接：<br/>
<a href="http://zguide.zeromq.org/py:all" rel="nofollow">http://zguide.zeromq.org/py:all</a><br/>
<a href="http://pyzmq.readthedocs.io/en/latest/api/" rel="nofollow">http://pyzmq.readthedocs.io/en/latest/api/</a><br/>
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/" rel="nofollow">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/</a><br/>
<a href="https://pyzmq.readthedocs.io/en/latest/api/index.html" rel="nofollow">https://pyzmq.readthedocs.io/en/latest/api/index.html</a></p>




            </div>
            <div class="post-info">
                <p class="post-tags">
                    
                        <a href="../tags/zmq">ZMQ</a>
                    
                        <a href="../tags/python">Python</a>
                    
                </p>
            </div>
        </article>
    </main>



    <footer>
        <p class="post-author">© <a href="/">zzir</a></p>
        <p class="foot-nav"><a href="/archives.html">Archive</a> | <a href="/about.html">About</a></p>
        <p class="beian">
            <span><img alt="zzir" src="/imgs/beian.png">浙公网安备33010902002287号</span>
            <span>浙ICP备19040093号</span>
        </p>
    </footer>



</body>
</html>
