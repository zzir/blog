<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="zzir">
    <meta name="description" content="">
    <meta name="keywords" content="">
    
    <link rel="stylesheet" href="../css/style.css">
    
    <link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Caveat&display=swap" rel="stylesheet" type="text/css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"></script>
    
    <link rel="stylesheet" href="../css/github.css">
    <script src="../js/highlight.pack.js"></script>
    <title>Python 多线程和锁 - zzir</title>

    <script>
        hljs.initHighlightingOnLoad();
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
</head>
<body>

    <main>
        <article>
            <h1 class="post-title">Python 多线程和锁</h1>
            <div class="post-info">
                <p class="post-date">Apr  5, 2017</p>
            </div>
            <div class="post-content">
                


  
  
  



<h2>进程和线程</h2>

<p>进程是执行中的计算机程序。每个进程都拥有自己的地址空间、内存、数据栈及其它的辅助数据。操作系统管理着所有的进程，并为这些进程合理分配时间。进程可以通过派生新的进程来执行其它任务，不过每个进程都拥有自己的内存和数据栈等，进程之间的数据交换采用 <strong>进程间通信(IPC)</strong> 方式。</p>

<p>线程在进程之下执行，一个进程下可以运行多个线程，它们之间共享相同上下文。线程包括开始、执行顺序和结束三部分。它有一个指针，用于记录当前运行的上下文。当其它线程执行时，它可以被抢占(中断)和临时挂起(也称睡眠) ——这种做法叫做 <strong>让步(yielding)</strong>。</p>

<p>一个进程中的各个线程与主进程共享同一片数据空间，与独立进程相比，线程之间信息共享和通信更加容易。线程一般以并发执行，正是由于这种并发和数据共享机制，使多任务间的协作成为可能。当然，这种共享也并不是没有风险的，如果多个线程访问同一数据空间，由于访问顺序不同，可能导致结果不一致，这种情况通常称为<strong>竞态条件(race condition)</strong>，不过大多数线程库都有同步原语，以允许线程管理器的控制执行和访问；另一个要注意的问题是，线程无法给予公平执行时间，CPU 时间分配会倾向那些阻塞更少的函数。</p>

<h2 id="全局解释器锁-gil">全局解释器锁(GIL)</h2>

<p>Python 代码执行由 <em>Python 虚拟机</em> (又名解释器主循环) 进行控制。Python 在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行。对 Python 虚拟机的访问由 <em>全局解释器(GIL)</em> 控制，这个锁用于，当有多个线程时保证同一时刻只能有一个线程在运行。</p>

<p>由于 Python 的 GIL 的限制，多线程更适合 I/O 密集型应用( I/O 释放了 GIL，可以允许更多的并发)，对于计算密集型应用，为了实现更好的并行性，适合使用多进程，已便利用 CPU 的多核优势。Python 的多进程相关模块：subprocess、multiprocessing、concurrent.futures</p>

<h2 id="threading-模块">threading 模块</h2>

<p>threading 是 Python 高级别的多线程模块。</p>

<h3 id="threading-模块的函数">threading 模块的函数</h3>

<ul>
<li><strong>active_count()</strong>  当前活动的 Thread 对象个数</li>
<li><strong>current_thread()</strong>  返回当前 Thread 对象</li>
<li><strong>get_ident()</strong>  返回当前线程</li>
<li><strong>enumerater()</strong>  返回当前活动 Thread 对象列表</li>
<li><strong>main_thread()</strong>  返回主 Thread 对象</li>
<li><strong>settrace(func)</strong>  为所有线程设置一个 trace 函数</li>
<li><strong>setprofile(func)</strong>  为所有线程设置一个 profile 函数</li>
<li><strong>stack_size([size])</strong>  返回新创建线程栈大小；或为后续创建的线程设定栈大小为 size</li>
<li><strong>TIMEOUT_MAX</strong>  <code>Lock.acquire()</code>, <code>RLock.acquire()</code>, <code>Condition.wait()</code> 允许的最大值</li>
</ul>

<p>threading 可用对象列表：</p>

<ul>
<li><strong>Thread</strong> 表示执行线程的对象</li>
<li><strong>Lock</strong>  锁原语对象</li>
<li><strong>RLock</strong>  可重入锁对象，使单一进程再次获得已持有的锁(递归锁)</li>
<li><strong>Condition</strong>  条件变量对象，使得一个线程等待另一个线程满足特定条件，比如改变状态或某个值</li>
<li><strong>Semaphore</strong>  为线程间共享的有限资源提供一个&#34;计数器&#34;，如果没有可用资源会被阻塞</li>
<li><strong>Event</strong>  条件变量的通用版本，任意数量的线程等待某个时间的发生，在改事件发生后所有线程被激活</li>
<li><strong>Timer</strong>  与 Thread 相识，不过它要在运行前等待一段时间</li>
<li><strong>Barrier</strong>  创建一个&#34;阻碍&#34;，必须达到指定数量的线程后才可以继续</li>
</ul>

<h3 id="thread-类">Thread 类</h3>

<p>Thread 对象的属性有：<code>Thread.name</code>、<code>Thread.ident</code>、<code>Thread.daemon</code>。详见(<em>The Python Standard Library</em>)</p>

<p>Thread 对象方法：<br/>
<code>Thread.start()</code>、<code>Thread.run()</code>、<code>Thread.join(timeout=None)</code>、<code>Thread.getName</code>、<code>Thread.setName</code>、<code>Thread.is_alive()</code>、<code>Thread.isDaemon()</code>、<code>Thread.setDaemon()</code>。详见(<em>The Python Standard Library</em>)</p>

<p>使用 Thread 类，可以有很多种方法来创建线程，这里使用常见的两种：</p>

<ul>
<li>创建 Thread 实例，传给它一个函数。</li>
<li>派生 Thread 子类，并创建子类的实例。</li>
</ul>

<h3>一个单线程栗子</h3>

<pre><code class="language-Python">#!/usr/bin/env python3

import threading
from random import randint
from time import sleep, ctime

def hi(n):
    sleep(n)
    print(&#34;ZzZzzz, sleep: &#34;, n)    # 打印 Sleep 的秒数

def main():
    print(&#34;### Start at: &#34;, ctime())

    for i in range(10):
        hi(randint(1,2))    # 调用十次，每次 Sleep 1秒或2秒

    print(&#34;### Done at: &#34;, ctime())

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>运行结果：</p>

<pre><code class="language-control">### Start at:  Thu Sep  1 14:11:00 2016
ZzZzzz, sleep:  1
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  2
### Done at:  Thu Sep  1 14:11:14 2016
</code></pre>

<p>一共是用了14秒。</p>

<h3 id="多线程-创建-thread-实例-传给它一个函数">多线程：创建 Thread 实例，传给它一个函数</h3>

<p>直接上代码：</p>

<pre><code class="language-Python">#!/usr/bin/env python3

import threading
from random import randint
from time import sleep, ctime

def hi(n):
    sleep(n)
    print(&#34;ZzZzzz, sleep: &#34;, n)

def main():
    print(&#34;### Start at: &#34;, ctime())
    threads = []

    for i in range(10):
        rands = randint(1,2)
        # 实例化每个 Thread 对象，把函数和参数传递进去，返回 Thread 实例
        t = threading.Thread(target=hi, args=(rands,))
        threads.append(t)     # 分配线程

    for i in range(10):
        threads[i].start()    # 开始执行多线程

    for i in range(10):
        threads[i].join()     # (自旋锁)等待线程结束或超时，然后再往下执行

    print(&#34;### Done at: &#34;, ctime())

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>运行结果：</p>

<pre><code class="language-control">### Start at:  Thu Sep  1 14:18:00 2016
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
### Done at:  Thu Sep  1 14:18:02 2016
</code></pre>

<p>使用多线程，只用了2秒。</p>

<h3 id="多线程-派生-thread-子类-并创建子类的实例">多线程：派生 Thread 子类，并创建子类的实例</h3>

<pre><code class="language-Python">#!/usr/bin/env python3

import threading
from random import randint
from time import sleep, ctime

class MyThread(threading.Thread):
 
    def __init__(self, func, args, times):
        super(MyThread, self).__init__()
        self.func = func
        self.args = args
        self.times = times
    
    def run(self):
        print(&#34;begin thread......&#34;, self.times)
        self.res = self.func(*self.args)
        print(&#34;end threads......&#34;, self.times)


def hi(n):
    sleep(n)
    print(&#34;ZzZzzz, sleep: &#34;, n)

def main():
    print(&#34;### Start at: &#34;, ctime())
    threads = []

    for i in range(10):
        rands = randint(1,2)
        t = MyThread(hi, (rands,), i+1)
        threads.append(t)

    for i in range(10):
        threads[i].start()

    for i in range(10):
        threads[i].join()

    print(&#34;### Done at: &#34;, ctime())

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>执行结果：</p>

<pre><code class="language-control">### Start at:  Thu Sep  1 14:47:09 2016
begin thread...... 1
begin thread...... 2
begin thread...... 3
begin thread...... 4
begin thread...... 5
begin thread...... 6
begin thread...... 7
begin thread...... 8
begin thread...... 9
begin thread...... 10
ZzZzzz, sleep:  1
ZzZzzz, sleep:  1
end threads...... 1
end threads...... 4
ZzZzzz, sleep:  1
end threads...... 7
ZzZzzz, sleep:  1
end threads...... 3
ZzZzzz, sleep:  1
end threads...... 9
ZzZzzz, sleep:  2
end threads...... 2
ZzZzzz, sleep:  2
end threads...... 5
ZzZzzz, sleep:  2
ZzZzzz, sleep:  2
end threads...... 10
end threads...... 6
ZzZzzz, sleep:  2
end threads...... 8
### Done at:  Thu Sep  1 14:47:11 2016
</code></pre>

<p>这个栗子对 Thread 子类化，而不是对其实例化，使得定制线程对象更具灵活性，同时也简化线程创建的调用过程。</p>

<h2>线程锁</h2>

<p>当多线程争夺锁时，允许第一个获得锁的线程进入临街区，并执行代码。所有之后到达的线程将被阻塞，直到第一个线程执行结束，退出临街区，并释放锁。需要注意，那些阻塞的线程是没有顺序的。</p>

<p>举个栗子：</p>

<pre><code class="language-python">#!/usr/bin/env python3

import threading
from random import randint
from time import sleep, ctime


L = threading.Lock()    # 引入锁


def hi(n):
    L.acquire()    # 加锁
    for i in [1, 2]:
        print(i)
        sleep(n)
        print(&#34;ZzZzzz, sleep: &#34;, n)
    L.release()    # 释放锁


def main():
    print(&#34;### Start at: &#34;, ctime())
    threads = []

    for i in range(10):
        rands = randint(1, 2)
        t = threading.Thread(target=hi, args=(rands,))
        threads.append(t)

    for i in range(10):
        threads[i].start()

    for i in range(10):
        threads[i].join()

    print(&#34;### Done at: &#34;, ctime())


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

<p>运行上面的代码，再将锁的代码注释掉，对比下输出。</p>




            </div>
            <div class="post-info">
                <p class="post-tags">
                    
                        <a href="../tags/threading">threading</a>
                    
                        <a href="../tags/python">Python</a>
                    
                </p>
            </div>
        </article>
    </main>



    <footer>
        <p class="post-author">© <a href="/">zzir</a></p>
        <p class="foot-nav"><a href="/archives.html">Archive</a> | <a href="/about.html">About</a></p>
        <p class="beian">
            <span><img alt="zzir" src="/imgs/beian.png">浙公网安备33010902002287号</span>
            <span>浙ICP备19040093号</span>
        </p>
    </footer>



</body>
</html>
