<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="zzir">
    <meta name="description" content="">
    <meta name="keywords" content="">
    
    <link rel="stylesheet" href="../css/style.css">
    
    <link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Caveat&display=swap" rel="stylesheet" type="text/css">
    
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"></script>
    
    <link rel="stylesheet" href="../css/github.css">
    <script src="../js/highlight.pack.js"></script>
    <title>Google Authentication (2FA) - zzir</title>

    <script>
        hljs.initHighlightingOnLoad();
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
</head>
<body>

    <main>
        <article>
            <h1 class="post-title">Google Authentication (2FA)</h1>
            <div class="post-info">
                <p class="post-date">Sep 14, 2017</p>
            </div>
            <div class="post-content">
                


  
  
  



<p><a href="https://daplie.github.io/browser-authenticator/" rel="nofollow">在线演示</a></p>

<p><a href="https://github.com/google/google-authenticator" rel="nofollow">Google Authentication</a> 支持 <a href="http://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm" rel="nofollow">HOTP</a> 和 <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" rel="nofollow">TOTP</a> 算法生成二次验证(2FA. two-factor authentication)密码。</p>

<h2 id="hotp-hmac-base-one-time-passowrd">HOTP(HMAC-base One-Time Passowrd)</h2>

<p>HMAC就是 Hash-based Message Authentication Code 的意思。</p>

<p>客户端和服务器事先协商好一个密钥，用于一次性密码的生成过程，此密钥不被任何第三方所知道。</p>

<p>此外，客户端和服务器各有一个计数器，并且事先将计数值同步。计算完成之后客户端计数器计数值加1。</p>

<p>用户将这一组十进制数输入并且提交之后，服务器端同样的计算，并且与用户提交的数值比较，如果相同，则验证通过，服务器端将计数值增加1。如果不相同，则验证失败。</p>

<h2 id="totp-time-base-one-time-password">TOTP(Time-base One-Time Password)</h2>

<p>理解了上面的HOTP，那TOTP只是将时间戳代替了计数器。于是就随时间戳变化生成不同密码。</p>

<h2 id="working">Working</h2>

<p>而实际上 Google Authentication 使用 TOTP。核心由三个部分组成。</p>

<ul>
<li>共享密钥</li>
<li>输入(时间戳)</li>
<li>签名</li>
</ul>

<h3>共享密钥</h3>

<p>共享密钥用于在其它客户端获得密码，可以手动输入，可以通过链接或者二维码获得。</p>

<p>注意密钥会被Base32编码，所以要去除空格并转换成大写。然后 保证处理后的密钥位数是8的倍数。</p>

<p>Google 服务使用4位8组共32位的密钥。其它使用 Google Authentication 的不尽相同，像 GitHub 则是16位的密钥。</p>

<p>密钥将URL转换成二维码方便手机或其它设备使用时候遵循以下格式：</p>

<pre><code>otpauth://TYPE/LABEL?PARAMETERS
</code></pre>

<p>比如这样：</p>

<pre><code>otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&amp;issuer=Example
</code></pre>

<p>详细内容可以参考<a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format" rel="nofollow">Key Uri Format</a></p>

<h3 id="输入-时间戳">输入(时间戳)</h3>

<p>TOTP 采用时间戳作为变量，不需要与服务器交互就可以得到密码。那么该如何选取呢？</p>

<p>因为时间每时每刻都在变化，如果选择一个变化太快的 input（例如从某一时间点开始的秒数），那么用户来不及输入密码。如果选择一个变化太慢的 input（例如从某一时间点开始的小时数），那么第三方攻击者就有充足的时间去尝试所有可能的一次性密码（试想6位数字的一次性密码仅仅有10\^6种组合），降低了密码的安全性。</p>

<p>除此之外，变化太慢的 input 还会导致另一个问题。如果用户需要在短时间内两次登录账户，由于密码是一次性的不可重用，用户必须等到下一个一次性密码被生成时才能登录，这意味着最多需要等待59分59秒！这显然不可接受。</p>

<p>综合以上考虑，Google选择了30秒作为时间片，时间戳输入的数值为从Unix epoch（1970年1月1日 00:00:00）来经历的30秒的个数。</p>

<p>还有一个问题是，由于网络延时，用户输入延迟等因素，可能当服务器端接收到一次性密码时，input的数值已经改变，这样就会导致服务器计算的一次性密码值与用户输入的不同，验证失败。解决这个问题个一个方法是，服务器计算当前时间片以及前面的n个时间片内的一次性密码值，只要其中有一个与用户输入的密码相同，则验证通过。当然，n不能太大，否则会降低安全性。</p>

<h3>签名</h3>

<p>签名使用 HMAC-SHA1 算法。以一个密钥和一个消息为输入，生成一个消息摘要作为输出。</p>

<p>因为算法是单向散列加密，结果不可逆，这样在保证密钥不被第三者知道的情况下，只有使用相同密钥和输入(时间戳)才会得到相同结果，服务端才能判断客户端是合法登录。</p>

<pre><code>h = hmac.new(key, msg, hashlib.sha1).digest()
</code></pre>

<h2 id="algorithm">Algorithm</h2>

<p><img src="/imgs/201709-3WpWR.jpg" alt=""/></p>

<p>伪代码：</p>

<pre><code>function GoogleAuthenticatorCode(string secret)
    key := base32decode(secret)
    message := floor(current Unix time / 30)
    hash := HMAC-SHA1(key, message)
    offset := last nibble of hash
    truncatedHash := hash[offset..offset+3]  //4 bytes starting at the offset
    Set the first bit of truncatedHash to zero  //remove the most significant bit
    code := truncatedHash mod 1000000
    pad code with 0 until length of code is 6
    return code
</code></pre>

<p>Python 实现:</p>

<pre><code class="language-Python">import hmac
import base64
import struct
import hashlib
import time
import sys

def get_hotp_token(secret, intervals_no):
    key = base64.b32decode(secret)
    msg = struct.pack(&#34;&gt;Q&#34;, intervals_no)
    h = hmac.new(key, msg, hashlib.sha1).digest()
    o = h[len(h)-1] &amp; 0x0f
    h = (struct.unpack(&#34;&gt;I&#34;, h[o:o + 4])[0] &amp; 0x7fffffff) % 1000000
    return h

def get_totp_token(secret):
    intervals_no = int(time.time()) // 30
    totp_token = get_hotp_token(secret, intervals_no)
    return totp_token

if __name__ == &#39;__main__&#39;:
    if len(sys.argv) != 2:
        print(&#39;Must specify key to use.&#39;)
        exit(1)
    Sec = sys.argv[1]
    Sec = Sec.replace(&#39; &#39;, &#39;&#39;).upper()
    if len(Sec) % 8 != 0:
        print(&#39;Illegal base32 data at input byte %d&#39; % ((len(Sec)//8+1)*8))
        exit(1)
    validation_code = get_totp_token(Sec)
    print(&#39;Code: %06d  (%02d second(s) remaining.)&#39; %
          (validation_code, 30 - int(time.time()) % 30))
</code></pre>

<p>这里还有一个Go的实现，<a href="https://gist.github.com/zzir/4346340d9f4122227d2031068a28248e" rel="nofollow">点我传送</a></p>

<h2 id="see-also">See Also</h2>

<p><a href="https://en.wikipedia.org/wiki/Google_Authenticator" rel="nofollow">https://en.wikipedia.org/wiki/Google_Authenticator</a><br/>
<a href="https://blog.seetee.me/post/2011/google-two-step-verification/" rel="nofollow">https://blog.seetee.me/post/2011/google-two-step-verification/</a><br/>
<a href="https://garbagecollected.org/2014/09/14/how-google-authenticator-works/" rel="nofollow">https://garbagecollected.org/2014/09/14/how-google-authenticator-works/</a><br/>
<a href="https://security.stackexchange.com/questions/35157/how-does-google-authenticator-work" rel="nofollow">https://security.stackexchange.com/questions/35157/how-does-google-authenticator-work</a></p>




            </div>
            <div class="post-info">
                <p class="post-tags">
                    
                        <a href="../tags/google">Google</a>
                    
                        <a href="../tags/2fa">2FA</a>
                    
                        <a href="../tags/python">Python</a>
                    
                </p>
            </div>
        </article>
    </main>



    <footer>
        <p class="post-author">© <a href="/">zzir</a></p>
        <p class="foot-nav"><a href="/archives.html">Archive</a> | <a href="/about.html">About</a></p>
        <p class="beian">
            <span><img alt="zzir" src="/imgs/beian.png">浙公网安备33010902002287号</span>
            <span>浙ICP备19040093号</span>
        </p>
    </footer>



</body>
</html>
