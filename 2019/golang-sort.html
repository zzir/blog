<!DOCTYPE html>
<html lang="zh"><head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="zzir">
    <meta name="description" content="The architect of civilization.">
    <meta name="keywords" content="zzir,Golang,Python,Docker,K8S">

    <link rel="stylesheet" href="/assets/css/style.css">

    <link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"
          type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Caveat&display=swap" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="/assets/css/github.css">

    <title>Golang 排序算法实现 - ZZIR's Blog</title>
</head><body>
<main class="page-content" aria-label="Content">
    <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="post-back" id="post-back" style="display: none">
        <a class="black-link" href="https://zzir.cn">🙄</a>
    </div>
    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">
            Golang 排序算法实现
        </h1>
        <p class="post-meta">
            <time class="dt-published" datetime="2019-03-24T00:00:00+08:00" itemprop="datePublished">Mar 24, 2019
            </time></p>
    </header>

    <div class="post-content e-content" itemprop="articleBody">
        <p><strong>O(N^2) 基于比较的排序算法</strong></p>

<ul>
  <li>冒泡排序 BUB</li>
  <li>选择排序 SEL</li>
  <li>插入排序 INS</li>
</ul>

<p>基于比较的排序算法比较数组的元素并决定是否交换它们。这三种排序算法最容易实现，但不是最高效的，因为它们的时间复杂度是O(N^2)。</p>

<p><strong>O(NlogN) 基于比较的排序算法</strong></p>

<ul>
  <li>堆排序</li>
  <li>希尔排序 SHE</li>
  <li>并归排序 MER</li>
  <li>快速排序 QUI
    <ul>
      <li>随机快速排序 R-Q</li>
    </ul>
  </li>
</ul>

<p>这些排序算法通常以递归方式实现，使用分而治之的思想解决问题。</p>

<p><strong>O(N) 不基于比较的排序算法</strong></p>

<ul>
  <li>计数排序 COU</li>
  <li>桶排序 BUC</li>
  <li>基数排序 RAD</li>
</ul>

<p><strong>复杂度和稳定性</strong></p>

<table>
  <thead>
    <tr>
      <th>算法</th>
      <th>时间复杂度(平均)</th>
      <th>时间复杂度(最坏)</th>
      <th>时间复杂度(最好)</th>
      <th>空间复杂度复</th>
      <th style="text-align: right">稳定性</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>冒泡排序</td>
      <td>$O(n^2)$</td>
      <td>$O(n^2)$</td>
      <td>$O(n)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td>选择排序</td>
      <td>$O(n^2)$</td>
      <td>$O(n^2)$</td>
      <td>$O(n^2)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">不稳定</td>
    </tr>
    <tr>
      <td>插入排序</td>
      <td>$O(n^2)$</td>
      <td>$O(n^2)$</td>
      <td>$O(n)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td>堆排序</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">不稳定</td>
    </tr>
    <tr>
      <td>希尔排序</td>
      <td>$O(n^{1.3})$</td>
      <td>$O(n^2)$</td>
      <td>$O(n)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">不稳定</td>
    </tr>
    <tr>
      <td>并归排序</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(1)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td>快速排序</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(n^2)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td>$O(nlog_{2}n)$</td>
      <td style="text-align: right">不稳定</td>
    </tr>
    <tr>
      <td>计数排序</td>
      <td>$O(n+k)$</td>
      <td>$O(n+k)$</td>
      <td>$O(n+k)$</td>
      <td>$O(n+k)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td>桶排序</td>
      <td>$O(n+k)$</td>
      <td>$O(n^2)$</td>
      <td>$O(n)$</td>
      <td>$O(n+k)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
    <tr>
      <td>基数排序</td>
      <td>$O(n*k)$</td>
      <td>$O(n*k)$</td>
      <td>$O(n*k)$</td>
      <td>$O(n+k)$</td>
      <td style="text-align: right">稳定</td>
    </tr>
  </tbody>
</table>

<!--more-->

<h2 id="冒泡排序-bubble-sort">冒泡排序 Bubble Sort</h2>

<p>算法的核心在于每次通过两两比较交换位置，选出剩余无序序列里最大(小)的数据元素放到队尾。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">BubbleSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="选择排序-selection-sort">选择排序 Selection Sort</h2>

<p>算法核心在于线性搜索数列并找到最大(小)值，并将最大(小)值替换为列中左端的数字并进行排序。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">SelectionSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">maxIndex</span> <span class="o">:=</span> <span class="m">0</span>
		<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">maxIndex</span> <span class="o">=</span> <span class="n">j</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="堆排序-heap-sort">堆排序 Heap Sort</h2>

<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">HeapSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">heapify</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
		<span class="n">siftDown</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">data</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">heapify</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="n">siftDown</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">siftDown</span><span class="p">(</span><span class="n">heap</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">root</span> <span class="o">:=</span> <span class="n">lo</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">child</span> <span class="o">:=</span> <span class="n">root</span><span class="o">*</span><span class="m">2</span> <span class="o">+</span> <span class="m">1</span>
		<span class="k">if</span> <span class="n">child</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">child</span><span class="o">+</span><span class="m">1</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">child</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">child</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">heap</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">heap</span><span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">child</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">child</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="插入排序-insertion-sort">插入排序 Insertion Sort</h2>

<p>插入排序的原理是，从第二个数开始向右侧遍历，每次均把该位置的元素移动至左侧，放在放在一个正确的位置(比左侧大，比右侧小)。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">InsertionSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span>
			<span class="n">temp</span> <span class="o">:=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="p">{</span>
				<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">j</span><span class="o">--</span>
			<span class="p">}</span>
			<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="希尔排序-shell-sort">希尔排序 Shell Sort</h2>

<p>1959 年 Shell 发明，第一个突破 O(n^2) 的排序算法，是简单插入排序的改进版。</p>

<p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ShellSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="n">h</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="k">for</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="m">3</span> <span class="p">{</span>
		<span class="n">h</span> <span class="o">=</span> <span class="m">3</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="m">1</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">h</span> <span class="o">&gt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">];</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">h</span> <span class="p">{</span>
				<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">h</span> <span class="o">/=</span> <span class="m">3</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="并归排序-merge-sort">并归排序 Merge Sort</h2>

<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">data</span>
	<span class="p">}</span>
	<span class="n">middle</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span>
	<span class="n">left</span> <span class="o">:=</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">:</span><span class="n">middle</span><span class="p">])</span>
	<span class="n">right</span> <span class="o">:=</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">middle</span><span class="o">:</span><span class="p">])</span>

	<span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">{</span>
				<span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
				<span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="快速排序-quick-sort">快速排序 Quick Sort</h2>

<p>快速排序的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">recursionSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">recursionSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">left</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
		<span class="n">pivot</span> <span class="o">:=</span> <span class="n">partition</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
		<span class="n">recursionSort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">pivot</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
		<span class="n">recursionSort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pivot</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">partition</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">left</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">right</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
			<span class="n">left</span><span class="o">++</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">left</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
			<span class="n">right</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">left</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="随机快速排序-random-quick-sort">随机快速排序 Random Quick Sort</h3>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">RandomQuickSort</span><span class="p">(</span><span class="n">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">:=</span> <span class="n">randomPartition</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">RandomQuickSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
		<span class="n">RandomQuickSort</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">randomPartition</span><span class="p">(</span><span class="n">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">rand</span><span class="o">.</span><span class="n">Seed</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="p">)</span>
	<span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">begin</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">begin</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">partition</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">partition</span><span class="p">(</span><span class="n">list</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cValue</span> <span class="o">:=</span> <span class="n">list</span><span class="p">[</span><span class="n">begin</span><span class="p">]</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">begin</span>
	<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cValue</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span>
			<span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">begin</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">begin</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">i</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="计数排序-counting-sort">计数排序 Counting Sort</h2>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">CountingSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">maxValue</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="n">bucketLen</span> <span class="o">:=</span> <span class="n">maxValue</span> <span class="o">+</span> <span class="m">1</span>
	<span class="n">bucket</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">bucketLen</span><span class="p">)</span>

	<span class="n">sortedIndex</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="n">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">bucket</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="m">1</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bucketLen</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">bucket</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
			<span class="n">sortedIndex</span> <span class="o">+=</span> <span class="m">1</span>
			<span class="n">bucket</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="m">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">data</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="桶排序-bucket-sort">桶排序 Bucket Sort</h2>

<p>桶排序是计数排序的升级版。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">insertionSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">:=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span>
		<span class="k">for</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="m">0</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BucketSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">bucketSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">max</span><span class="p">,</span> <span class="n">min</span> <span class="kt">int</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="p">{</span>
			<span class="n">min</span> <span class="o">=</span> <span class="n">n</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">n</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nBuckets</span> <span class="o">:=</span> <span class="kt">int</span><span class="p">(</span><span class="n">max</span><span class="o">-</span><span class="n">min</span><span class="p">)</span><span class="o">/</span><span class="n">bucketSize</span> <span class="o">+</span> <span class="m">1</span>
	<span class="n">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">nBuckets</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nBuckets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">buckets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">:=</span> <span class="kt">int</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bucketSize</span>
		<span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">sorted</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">buckets</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
			<span class="n">insertionSort</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
			<span class="n">sorted</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="n">bucket</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sorted</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基数排序-radix-sort">基数排序 Radix Sort</h2>

<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">findLargestNum</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">largestNum</span> <span class="o">:=</span> <span class="m">0</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">largestNum</span> <span class="p">{</span>
			<span class="n">largestNum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">largestNum</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">RadixSort</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">largestNum</span> <span class="o">:=</span> <span class="n">findLargestNum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="n">size</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="n">significantDigit</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="n">semiSorted</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">largestNum</span><span class="o">/</span><span class="n">significantDigit</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">:=</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">0</span><span class="p">}</span>

		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">bucket</span><span class="p">[(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">significantDigit</span><span class="p">)</span><span class="o">%</span><span class="m">10</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">size</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
			<span class="n">bucket</span><span class="p">[(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">significantDigit</span><span class="p">)</span><span class="o">%</span><span class="m">10</span><span class="p">]</span><span class="o">--</span>
			<span class="n">semiSorted</span><span class="p">[</span><span class="n">bucket</span><span class="p">[(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">significantDigit</span><span class="p">)</span><span class="o">%</span><span class="m">10</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">semiSorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="n">significantDigit</span> <span class="o">*=</span> <span class="m">10</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


    </div>

    <a class="u-url" href="/2019/golang-sort.html" hidden></a>
</article>

<div class="post-tags">
    
    <a>Sort</a>
    
    <a>Algorithm</a>
    
</div>

<div class="pagination">
    <ul>
        
        <li class="prev">
            <a href="/2018/bitcoin-blockchain.html" title="PREV: Bitcoin 区块和交易数据结构">
                ‹ Bitcoin 区块和交易数据结构
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2019/docker-quick-handbook.html" title="NEXT: Docker 常用操作">
                › Docker 常用操作
            </a>
        </li>
        
    </ul>
</div>
    </div>
</main><footer>
    <p class="post-author">© <a href="/">zzir</a></p>
    <p class="beian">
        
        <span>
            <img src="/assets/imgs/beian.png">
            <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010902002287">浙公网安备33010902002287号</a>
        </span>
        ・︎
        <span><a href="http://beian.miit.gov.cn/">浙ICP备19040093号</a></span>
        
    </p>
</footer>
<script defer src="/assets/js/katex/katex.min.js" type="text/javascript"></script>
<script defer src="/assets/js/katex/auto-render.min.js" type="text/javascript"></script>
<script src="/assets/js/zooming.min.js" type="text/javascript"></script>
<script src="/assets/js/highlight.pack.js" type="text/javascript"></script>
<script>
    // zooming
    const zooming = new Zooming({
        customSize: '100%',
    });
    zooming.listen('.paragraph img');
    zooming.listen('.content img');
    zooming.listen('.post-content img');

    // highlight
    hljs.initHighlightingOnLoad();

    // katex
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });

    // back display
    function getScrollTop() {
        var scrollTop = 0;
        if (document.documentElement && document.documentElement.scrollTop) {
            scrollTop = document.documentElement.scrollTop;
        } else if (document.body) {
            scrollTop = document.body.scrollTop;
        }
        return scrollTop;
    }

    window.onscroll = function () {
        if (getScrollTop() === 0) {
            document.getElementById("post-back").style.display = "block";
        }
    }
</script>


<script>
    // google analytics
    window.ga = window.ga || function () {
        (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'UA-121779014-1', 'auto');
    ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>
</html>